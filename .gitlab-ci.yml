# Define the stages of the CI/CD pipeline
stages:
    - build       # The first stage, responsible for building the project
    - lint        # The second stage, responsible for testing code quality
    - test        # The third stage, responsible for testing the backend application
    - registry    # The fourth stage, responsible for building and pushing Docker images
   

cache:
  key: cache-$CI_COMMIT_REF_SLUG
  paths:
    - node_modules/
    - package-lock.json

# Define a job named 'build-backend'
build-backend:
    image: node:23-bookworm  # Use a Node.js image (based on Debian Bookworm) as the environment
    stage: build             # Assign this job to the 'build' stage
    script:
      - yarn install         # Install project dependencies using Yarn

# Test code linting with eslint
eslint-check:
    image: node:23-bookworm  # Use a Node.js image (based on Debian Bookworm) as the environment
    stage: lint
    script:
      - yarn lint       # Run ESLint to check the codebase for errors

  # Define a job named 'jest-test'
jest-test:
    image: node:23-bookworm 
    stage: test
    script:
      - npm run test

locust-stress-test:
    image: nikolaik/python-nodejs:latest # Image that contains NodeJS and python
    stage: test
    script:
      - python3 -m venv .venv
      - source .venv/bin/activate
      - pip install -r requirements.txt
      - yarn run start & npx wait-on http://localhost:3000
      - locust --headless --users 1000 --spawn-rate 1 -H http://localhost:3000 -t 15s
    needs:
      - build-backend

# Define a job named 'build-dev-docker-image'
build-dev-docker-image:
    image: docker
    stage: registry          # Assign this job to the 'registry' stage
    services:
      - docker:dind
    variables:
      DOCKER_HOST: tcp://docker:2375
      DOCKER_TLS_CERTDIR: ""  # Disbale TLS to simplify Docker connections
    before_script:
      - echo "Docker registry url is $CI_REGISTRY"          # Output the Docker registry URL
      - echo "Docker registry username is $CI_REGISTRY_USER" # Output the Docker registry username
      - echo "Docker registry repo is $CI_REGISTRY_IMAGE"   # Output the Docker repository name
    script:
      - docker build -t ${CI_REGISTRY_IMAGE}:latest-dev -t ${CI_REGISTRY_IMAGE}:$CI_COMMIT_SHORT_SHA . # Build a Docker image with "latest-dev" and SHA tags
      - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY # Log in to the Docker registry
      - docker push ${CI_REGISTRY_IMAGE}:latest-dev       # Push the "latest-dev" tagged image
      - docker push ${CI_REGISTRY_IMAGE}:$CI_COMMIT_SHORT_SHA # Push the SHA-tagged image
    only:
      - main        # Execute this job only on the `main` branch

  # Define a job named 'build-prod-docker-image'
build-prod-docker-image:
    image: docker
    stage: registry          # Assign this job to the 'registry' stage
    services:
      - docker:dind
    variables:
      DOCKER_HOST: tcp://docker:2375
      DOCKER_TLS_CERTDIR: ""  # Disbale TLS to simplify Docker connections
    before_script:
      - export PACKAGE_VERSION="$(cat  package.json | grep \"version\" | cut -d'"' -f 4"
      - echo "Package version is $PACKAGE_VERSION"          # Output the applicative version declared into the package.json file
      - echo "Docker registry url is $CI_REGISTRY"          # Output the Docker registry URL
      - echo "Docker registry username is $CI_REGISTRY_USER" # Output the Docker registry username
      - echo "Docker registry repo is $CI_REGISTRY_IMAGE"   # Output the Docker repository name
    script:
      - docker build -t ${CI_REGISTRY_IMAGE}:latest -t ${CI_REGISTRY_IMAGE}:$PACKAGE_VERSION . # Build a Docker image with "latest" and applicative version
      - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY # Log in to the Docker registry
      - docker push ${CI_REGISTRY_IMAGE}:latest       # Push the "latest" tagged image
      - docker push ${CI_REGISTRY_IMAGE}:$PACKAGE_VERSION # Push the applicative version tagged image
    only:
      - preprod        # Execute this job only on the `preprod` branch




